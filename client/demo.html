<!DOCTYPE html>
<meta charset='utf-8'>
<script type='text/javascript' src='https://code.jquery.com/jquery-1.12.1.js'></script>
<script src='http://d3js.org/d3.v3.min.js'></script>
<style>
*                     { margin: 0;  padding: 0;  outline: none;  box-sizing: border-box; }
body                  { background: #AAAAAA; margin-top:50; }
button                { font: 20px system-ui; margin:5px;}
#content              { position:relative;  margin-top:2px;  margin-left: 5%; }
.abs                  { position:absolute; }
.fresh.cellBackground { fill:blue;  }
</style>
<!--
<pre>
stack11 click a cell to get info
console cmnds:
 $.map(cells,(d)=> d.setState('placed'))
 $.map(cells,(d)=> d.setState('on'    ))
 $.map(cells,(d,k)=> hiliteTree(k))
 

 
 showTrees()
 hiliteTree(7)
 hiliteCellsWithTree(7)
 numberOfCellsInEachTree()
 discoveredCells.length  // 80
 hiliteCellsWithTree(2)
 $.map(cells,(d)=> console.log(d.id,cellsWithTree(d.id)))
 numberOfCellsInEachTree().reduce((acc,val)=> acc+val, 0);  // 625 = 25*25 - treeAdds
 treeAdds   // 24*25
-------------------------------------------
link.state goes to 'on' ea cell of the link gets a 'discover' msg containing the port
see DTA-Section5

TBD: 
tests: how many unconnected regions we have
have a max cnt and record condn for when this happens,  allow setting a bkpt
print maxCnt as it increases
</pre>
-->
<div id='controls' style="padding-left: 50px;">
  <button id='pause'   >pause      </button>   <button id='resume' >resume   </button> <br/>
  <button id='faster'  >->         </button>   <button id='slower' >+>       </button> <br/>
  <button id='tile'    >tiled view </button>
  <button id='stacked' >stacked    </button>
  <button id='nstacked'>nice stack </button>
  <button id='topview' >top view   </button> <br/>
</div>
<div id="info" style="height:100px; padding-left: 50px;"> --- 
  <!-- when click a cell or link, info appears here zzz -->
</div>

<svg height='0'>
 <defs>
  <marker id="marker_arrow" 
    orient="auto" 
    refX="-5" refY="0" viewBox="-5 -5 10 10" markerWidth="1" markerheight="1" 
   >
   <path id="marker_arrow_path" d="M 0,0 m -5,-5  L 5,0  L -5,5  Z" fill="red"></path>
  </marker>
 </defs>
</svg>
<table id="content_panel">
 <tr>
   <div id='heading' style="padding-left: 50px;"><h2>
     Datacenter Graph &nbsp;&nbsp;&nbsp;&nbsp;
     Reachability Matrix</h2>
   </div>
  </tr>
 <tr>
  <td             ><div id="content"></div></td>
  <td valign="top"><div id="panel"  ></div></td>
 </tr>
</table>
<script>
/*
stackoverflow.com/questions/424292/seedable-javascript-random-number-generator
stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
*/
var randumb=((__,seed=1)=>  // gives the same series of numbers every time
  (__,x=Math.sin(seed++)*10000)=> x - Math.floor(x)
)();
//var Math_random=Math.random();
/*
  $('svg').append($(SVGnode('line'))
    .attr({ x1:20, y1:20, x2:100, y2:20, 
      "stroke-width":18, stroke:'blue', 
      "marker-end":'url(#marker_arrow)' 
    })
  );
*/
var Math_random=randumb;
var random= (arr)=> arr[Math.floor(arr.length*Math_random())]; 
var svgNS="http://www.w3.org/2000/svg", DIV='<div>';
var SVGnode= (tag)=> document.createElementNS(svgNS,tag);
var line= (parent,x1,y1,x2,y2,stroke,width,__,aLine)=> {
  aLine=$(SVGnode('line'))
  parent.append(aLine.attr({ x1:x1, y1:y1, x2:x2, y2:y2, stroke:stroke, "stroke-width":width }));
  return aLine;
};
var color = d3.scale.category10();
// ========================================================= positioning
/*
port numbering convention:

     5  1  4
      \ | /
    2 - o - 0
      / | \
     6  3  7
*/

var spacing=38;
var f45=Math.cos(Math.PI/4);
var col= (k)=> k%nCol;
var row= (k)=> Math.floor(k/nCol);

var x=   (k)=> (spacing/2)+spacing*col(k);  // cell position
var y=   (k)=> (spacing/2)+spacing*row(k);  
var px= [ 1, 0,-1, 0,  f45, -f45, -f45, f45 ]; // port position wrt cell
var py= [ 0,-1, 0, 1, -f45, -f45,  f45, f45 ];
var endPts=(d,__,r=7)=>({  // d is a link, link endPts are cell ports
  x1:d.cell1.x+ 1.1*r*px[d.cell1Port],
  y1:d.cell1.y+ 1.1*r*py[d.cell1Port],
  x2:d.cell2.x+ 1.1*r*px[d.cell2Port],
  y2:d.cell2.y+ 1.1*r*py[d.cell2Port]
});

var linkEndPts=(d,__,r=7)=> ({
  x1:d.cell1.x+ (d.state=='connected2' ? 2.1 : 1)*r*px[d.cell1Port],
  y1:d.cell1.y+ (d.state=='connected2' ? 2.1 : 1)*r*py[d.cell1Port],
  x2:d.cell2.x+ (d.state=='connected1' ? 2.1 : 1)*r*px[d.cell2Port],
  y2:d.cell2.y+ (d.state=='connected1' ? 2.1 : 1)*r*py[d.cell2Port]
});
var branchEndPts=(pt1,port1,pt2,port2,__,r=7)=> { 
  var foo={  // pt1 is the head or point to the line 
  // test 
  // link=links[3];
  // $('#base1').append($(SVGnode('line'))
  //   .attr(branchEndPts(link,link.cell1,link.cell2)).attr({ "stroke-width":5, stroke:'red'}));

  // https://www.w3.org/TR/SVG11/images/painting/linejoin.svg
  // miter round bevel
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap
  //  stroke-linecap  butt | round | square | inherit
    x1:pt1.x+ 2.1*r*px[port1],
    y1:pt1.y+ 2.1*r*py[port1],
    x2:pt2.x+     r*px[port2],
    y2:pt2.y+     r*py[port2]
  }
  return foo;
};
var branchEndPtsR=(pt1,port1,pt2,port2,__,r=7)=> { 
  var foo={  // pt1 is the head or point to the line 
  // test 
  // link=links[3];
  // $('#base1').append($(SVGnode('line'))
  //   .attr(branchEndPts(link,link.cell1,link.cell2)).attr({ "stroke-width":5, stroke:'red'}));

  // https://www.w3.org/TR/SVG11/images/painting/linejoin.svg
  // miter round bevel
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap
  //  stroke-linecap  butt | round | square | inherit
    x1:pt1.x+     r*px[port1],
    y1:pt1.y+     r*py[port1],
    x2:pt2.x+ 1.5*r*px[port2],
    y2:pt2.y+ 1.5*r*py[port2]
  }
  return foo;
};


// ========================================================= MODEL - CELL
var maxCnt=0;   // max hop count
var treeAdds=0; // how many branches have been created
// hard wire cell positions

var Cell=function(k,__,self,getOtherCell,getOtherPort){
  getOtherCell=(link)=> (link==null) ? null : ((link.cell1==self) ? link.cell2     : link.cell1    ),
  getOtherPort=(link)=> (link==null) ? null : ((link.cell1==self) ? link.cell2Port : link.cell1Port),
  self={ 
    id:k,  // need a closure for uuid generation - in our case the k index has a spl meaning
    uuid:k,
    k:k, 
    row:row(k), 
    col:col(k),
    
    x:x(k),
    y:y(k),
    state:'unplaced',  // unplaced,placed,on    
    ports:[
      { link:null, trees:{} },
      { link:null, trees:{} },
      { link:null, trees:{} },
      { link:null, trees:{} }
    ],    // r t l b
    notifyPorts:()=> $.map(self.ports,(d)=> (d.link && d.link.update())), // called by .setState
    setPort:(porti,link)=>{ self.ports[porti].link=link; },
    trees:{ /* k:{ id:k, in:null, out:{}, pruned:{} } */},
    setState:(state,__,state0)=>{   // FSM  needed - suggestions please  sends .update msg to links
      state0=self.state;
      if(self.state=='unplaced' && state=='placed'){ self.state='placed'; 
        self.update(); 
        self.notifyPorts(); 
      }
      if(self.state=='placed'   && state=='on'    ){ self.state='on'; 
        self.trees[k]= { id:k, in:null, out:{}, pruned:{} }; 
        self.update(); 
        self.notifyPorts(); 
      }
      return self.state; 
    },
    propagateTreeOnPort:(treeID,port_out,cnt,__,link,otherCell,otherPort)=>{ 
      if(self.ports[port_out].trees[treeID]){ return; }  // already sent  GGGG
      maxCnt= cnt>maxCnt ? cnt : maxCnt;
      // only called when self.ports[port_out].link.state='on'  DDDD
      link=self.ports[port_out].link;
      if(link==null || link.state!='on'){ alert('oops'); return; } // redundant ck DDDD
      
      otherCell=getOtherCell(link);
      otherPort=getOtherPort(link);
            
      if(otherCell.trees[treeID]==undefined){         
        link_observers.update(link,treeID,'hilitePropagation',
            {cell1:self,port1:port_out,cell2:otherCell,port2:otherPort,tree:treeID,cnt:cnt});
        self     .trees[treeID].out[port_out]=true;
        otherCell.trees[treeID]={ id:treeID, in:otherPort, out:{}, pruned:{} }; // send out
        treeAdds+=1;  //  25x(25-1)  the tree rooted on ea cell must be send to all the other cells
        
        otherCell.update();
      //link_observers.update(link,treeID,'tree_branch',{ x1:self.x, y1:self.y, x2:otherCell.x, y2:otherCell.y });  
        link_observers.update(link,treeID,'tree_branch',branchEndPtsR(self,port_out,otherCell,otherPort));            
      //otherCell.update();  // putting it second partially shades the link, and is an indicator of directionality

        self     .ports[port_out ].trees[treeID]=true; // GGGG
        otherCell.ports[otherPort].trees[treeID]=true; // no need to echo
        
        $.map(otherCell.ports,(port,k,__)=>{ // send out
          if(port.link && port.link.state=='on' && port!=otherPort){
            setTimeout(()=>otherCell.propagateTreeOnPort(treeID,k,cnt+1),300); // zzzz
          }
        });
      }
      else {  // when have a pruned branch
        return;  // TBD
      
        self.ports[port_out].pruned[treeID]=true;
        getOtherCell(link).ports[port].pruned[treeID]==true;
      }     
    },
    broadcastTree:(treeID,port_out,cnt,__)=>{  // called by Link.triggerDiscover when a link turns 'on'
      if(self.ports[port_out].link && self.ports[port_out].link.state=='on'){  // always
        self.propagateTreeOnPort(treeID,port_out,cnt); 
      }
    },
    broadcastTrees:(port_out,__)=>{  // called by Link.triggerDiscover when a link turns 'on'
      if(self.ports[port_out].link && self.ports[port_out].link.state=='on'){  // always
        $.map(self.trees,(tree)=> self.propagateTreeOnPort(tree.id,port_out,0) );
      }
    },  
    attr:{
      unplaced:{cx:x(k),cy:y(k),r:8, z:k, fill:'gray'   },
      placed  :{cx:x(k),cy:y(k),r:8, z:k, fill:'black' },
      on      :{cx:x(k),cy:y(k),r:8, z:k, fill:'green'  }
    },
    update:()=>{ cell_observers.update(self); } // called by .setState
  }
  return self;
};
var cellHash={}; 
var getCell= (row,col)=> cellHash[row+'_'+col];
// ========================================================= MODEL - LINK
var linkID=(c1,c2)=> c1.id<c2.id ? c1.id+'_'+c2.id : c2.id+'_'+c1.id;
var Link=function(d,port,d2,__,self){
  self={ 
    id:linkID(d,d2),
    cell1:d, 
    cell1Port:port, 
    cell2:d2, 
    cell2Port:(port+2)%4,
    attr:{
      unplaced  :{ stroke:'gray'   },
      connected1:{ stroke:'black'  },
      connected2:{ stroke:'black'  },
      placed    :{ stroke:'black'  },  // yellow
      on        :{ stroke:'green'  }
    },
    state:'unplaced', // *unplaced connected1 connected2 placed on
    setState:(state)=>{   // FSM  needed - suggestions please
    
    /* FSM logic
    
    unplaced  ____> connected1 __(connect2)______> placed __(both cells on **)__> on
               \__> connected2 __(connect1)__/
                 
    ** link needs to listen to cells  // implemented by cell sending .update() to links
    
    */
      if(state=='connected1' && self.cell1.state!="unplaced" && 
         (self.state=="unplaced" || self.state=="connected2")  ){
        self.cell1.setPort(self.cell1Port,self);
      //self.cell1.ports[self.cell1Port].link=self;
        if(self.state=="unplaced"){
          self.state='connected1'; 
          self.view.attr(linkEndPts(self)).attr({ "stroke-width":3 }).attr(self.attr[self.state]);  
        }    
        else if(self.state=='connected2'){
          self.setState('placed');
        } 
      }
 
      if(state=='connected2' && self.cell2.state!="unplaced" && 
         (self.state=="unplaced" || self.state=="connected1")  ){
        self.cell2.setPort(self.cell2Port,self);
      //self.cell2.ports[self.cell2Port].link=self;
        if(self.state=="unplaced"){
          self.state='connected2'; 
          self.view.attr(linkEndPts(self)).attr({ "stroke-width":3 }).attr(self.attr[self.state]);  
        }    
        else if(self.state=='connected1'){
          self.setState('placed');
        } 
      }     
    
      if(state=='placed'){ 
        self.state='placed';
        self.view.attr(linkEndPts(self)).attr({ "stroke-width":3 }).attr(self.attr[self.state]);      
        if(self.cell1.state=='on' && self.cell2.state=='on'){ self.setState('on'); } // state change zzzz hidden away
      }
      if(state=='on'){ 
        self.state='on'; self.view.attr(self.attr[self.state]); 
        if(self.cell1.state!="on" || self.cell2.state!="on"){ 
          console.log('error - trying to set link to on when an endpt cell is not on'); 
        }
        self.triggerDiscover();
      }
      return self.state; 
    },
    update:()=>{  // when cells change state, we get this method called
      if(self.state=="placed" && self.cell1.state=="on" && self.cell2.state=="on"){
        self.setState('on'); 
      }
    },
    triggerDiscover:()=>{  // called when state -> 'on' 
      $('.fresh').removeClass('fresh');
      $('.freshLink').remove();
      //$('#base1').remove();
      //$('#base2').remove();
      $('#base2').append($(SVGnode('circle')).attr({cx:x(self.cell1.id),cy:y(self.cell1.id),r:5,fill:'orange'}));
      $('#base2').append($(SVGnode('circle')).attr({cx:x(self.cell2.id),cy:y(self.cell2.id),r:5,fill:'pink'}));
      $('#info').html('discover between '+self.cell1.id+' - '+self.cell2.id);
    //console.log('link on',self.cell1.id,self.cell2.id,'--------------------------------------')
      self.cell1.broadcastTrees(self.cell1Port); discoveredCells.push(self.cell1.id);
      self.cell2.broadcastTrees(self.cell2Port); discoveredCells.push(self.cell2.id);
    }                    
  };
  self.view=$(SVGnode('line')).attr(linkEndPts(self)).attr({'class':self.id})
             .attr({ "stroke-width":2 }).attr(self.attr[self.state]);
  return self;   // receiver still needs to append self.view
};

var Links= (cells)=> {
  $.map(cells,(d,k,__,d2,mkLinkWhenDoesNotExist)=> { 
    mkLinkWhenDoesNotExist= (d,port,d2,__,link,lid)=> { 
      lid=linkID(d,d2);
      if(linkHash[lid]==undefined){ 
        link=Link(d,port,d2); 
        links.push(link); 
        linkHash[link.id]=link;
      } 
    };
    // for ea port: find its potential neighbor cell; make a link if it does not already exist
    if(d2=getCell(d.row+0,d.col+1)){ mkLinkWhenDoesNotExist(d,0,d2); } // right
    if(d2=getCell(d.row-1,d.col+0)){ mkLinkWhenDoesNotExist(d,1,d2); } // above
    if(d2=getCell(d.row+0,d.col-1)){ mkLinkWhenDoesNotExist(d,2,d2); } // left
    if(d2=getCell(d.row+1,d.col+0)){ mkLinkWhenDoesNotExist(d,3,d2); } // below
  });
};
// ========================================================= layout and arrangements
var nCol=5, nRow=4;  // 5 x 4  or  8 x 12
var wid=nCol*spacing, ht=nRow*spacing;
var topLayer,svg;  // kludge  // defined and placed last, so is at top

$('#content').css({width:(nCol*nCol*spacing)+nCol*4+70}); // zzz why need the 100 fudge?
$('#panel').html('panel');

var stdView=()=> {
  $('#connectionTable').css({
    transform:
        "translateX("+(wid+40)+"px) "
  }).html(' ')
  $('.baseTile').css({ 
    "z-index":3020, transition:"all 2.5s ease-out",transform:"", opacity:1, x:30,
    'box-shadow':"0px 0px 10px 2px rgba(0,0,0,0.7)"
  });
  $('.tileBackground').css({ opacity:0.0 });
  $('.cellBackground').css({ opacity:1   });
  $('.branch'        ).css({'stroke-width':4});
  
  $('.tile'          ).css({
    transition:"all 2.5s ease-out",
    transform:"",
    "box-shadow":"0px 0px 10px 2px rgba(0,0,0,0.7)",
    opacity:0 
  });
};
var stackedView=(kFocus,__,skew)=>{
//skew=(z)=> "rotateX(45deg) rotateZ(45deg) translateZ(-"+z+"px)";
  skew=(z)=> "rotateX(80deg) rotateZ(17deg) translateZ(-"+z+"px)"; // z must be >0

  $('.baseTile').css({ 
    "z-index":3020, transition:"all 2.5s ease-out",transform:skew(0), opacity:1, 
    'box-shadow':"0px 0px 10px 2px rgba(0,0,0,0.7)" 
  });
  $('.tileBackground').css({ opacity:0.0  });  // 0.05 is lowest value w/a change
  $('.cellBackground').css({ opacity:0.15 });
  $('.branch'        ).css({'stroke-width':4});
    
  $.map($('.tile'),(d,k)=> {
    $(d).css({
      transition:"all 2.5s ease-out",
      transform:skew((k*40)+1),
      "box-shadow":"0px 0px 2px 1px rgba(0,0,0,0.2)",
      opacity:1
    });
    // maybe raise the focus layer      "z-index":0, 
  });
};
var niceStackView=(__,skew)=>{
  skew=(z)=> "rotateX(5deg) rotateZ(5deg) translateZ(-"+z+"px)"; // // z must be >0
  
  $('.baseTile').css({ 
    "z-index":3020, transition:"all 2.5s ease-out",transform:skew(0), opacity:1, 
    'box-shadow':"0px 0px 10px 2px rgba(0,0,0,0.7)" 
  });
  $('.tileBackground').css({ opacity:0.0  });
  $('.cellBackground').css({ opacity:0.03 });
  $('.branch'        ).css({'stroke-width':3});  
  
  $.map($('.tile'),(d,k)=> $(d).css({
    transition:"all 2.5s ease-out",
    transform:skew((k*40)+1),
    "box-shadow":"0px 0px 2px 1px rgba(0,0,0,0.2)",
    'z-index':3000-k,
    opacity:1
  }));

};
var tile=()=>{
  $('.baseTile').css({ 
    "z-index":3020, transition:"all 2.5s ease-out",transform:"", opacity:1, 
    'box-shadow':"0px 0px 10px 2px rgba(0,0,0,0.7)" 
  });
  $('.tileBackground').css({ opacity:0.1 });
  $('.cellBackground').css({ opacity:0.2 });
  $('.branch'        ).css({'stroke-width':4});  
  
  $.map($('.tile'),(d,k)=> {
    $(d).css({
      transition:"all 2.5s ease-out",
      transform:
        "translateX("+((k%nCol)*(wid+7))+"px) "+
        // the extra ht so tiles are not over toplayer
        "translateY("+((ht+4)+((Math.floor((k/nCol))*(ht+7))))+"px)", 
      "box-shadow":"0px 0px 10px 2px rgba(0,0,0,0.7)",
      opacity:1 
    });
  // find the child with .tileBackground and set opactiy to 1.0
  });
};


var Tile=(k,__,layer)=>{
  layer=$(DIV)
    .attr({'class':"abs tile"})
    .css({ width:wid, height:ht })
    .data('z',k)  // is this what I want?
  ;
  // ea layer has a semitransparent background and a SVG w/objs and separate opacity
  layer.append($(DIV).attr({'class':'abs tileBackground'})
    .css({ width:wid, height:ht, background:color(k), opacity:0.1})
  );
  layer.svg=$(SVGnode('svg')).attr({id:'tile'+k, 'class':'tileSVG', width:wid, height:ht, xmlns:svgNS });
  layer.append($(DIV).attr({ 'class':'abs'}).append(layer.svg));
  return layer;
};

var layout=()=>{
/*
developer.mozilla.org/en-US/docs/Web/CSS/border
 $('table').css({'border':'10px dotted'})
 $('td').css({'border':'5px solid red'})
*/
  // the 2nd td  - in html it is valign
  // .css({'vertical-align':'top'})

  // everything I put into #content is absolutely positioned (ie the tiles)
  // so we have to fix the size
  $('#content').css({ width:(nCol*nCol*spacing)+nCol*4+70, height:(nRow*nRow*spacing)+nRow*4+70 });
  

};

// ========================================================= RENDER (the cells)
var renderCells=(svg)=> $.map(cells,(d,k)=>
  $('#toplayer').append( 
    $(SVGnode('circle')).data({k:k, cell:d})
                        .attr(d.attr[d.state]).attr({'class':'cell cell_'+k}) // JJJJ
  )
);
var renderedCells={};

var cell_observers={  
  update:(cell)=>{
    $('.cell_'+cell.id).attr(cell.attr[cell.state]);  // JJJJ  
    
    $.map(cell.trees,(tree)=>{ // we must go over all properties since update doesnt say what changed
    //  $.map($('.tile svg'),(d,k,__,tile)=>{  DDDD
      //if($('#tile'+k+'.cellBackground.cell'+tree.id).length==0){ // slows things to crawl
        if(!renderedCells[tree.id+'_'+cell.id]){
          renderedCells[tree.id+'_'+cell.id]=true;
          //$(d)   DDDD
          $('#tile'+tree.id).append(  //  x and y logic not understood
            $(SVGnode('rect'))
              .attr({ class:'fresh cellBackground cell'+cell.id, 
                x:(x(cell.k)-spacing/2),y:(y(cell.k)-spacing/2),width:spacing-1,height:spacing-1,
                fill:'green', opacity:0.3
              })
              .data({cell:cell})
          );
          //$(d)  DDDD
          $('#tile'+tree.id).append(
            $(SVGnode('circle'))
              .attr({ class:'fresh cell cell'+cell.id, 
                      cx:x(cell.k),cy:y(cell.k),r:(tree.id==cell.id) ? 8 : 5,
                      fill:(tree.id==cell.id) ? '#FF7777' : 'yellow' 
              })
              .data({cell:cell})
          )
        };
    //  })  // over ea tile/tree
    }) // over ea cell.tree
  }   // update
};

var link_observers={  
  update:(link,treeID,op,data)=>{
    if(op=='hilitePropagation'){ // data is {cell1:, port1:, cell2:, port2:, tree: ,cnt: }
      $('#base'+2).append(
        $(SVGnode('line'))
          .attr(branchEndPts(data.cell1,data.port1,data.cell2,data.port2)).attr({'class':'self.id freshLink'})
          .attr({ "stroke-width":(15-data.cnt) }).attr({stroke:[0,'red','blue'][2]})  // layer is 2
      );                  
      return;
    }
 

    // from hiliteTree - put in rendering section
    /*
    $('#tile'+treeID).append(
      $(SVGnode('line')).attr(endPts(link))
        .attr({ "class":'branch '+'connection_'+treeID+'_'+link.id,"stroke-width":4, stroke:'yellow'})
    );
    */
    if(op=='tree_branch'){
      // marker_arrow_path
      $('#marker_arrow_path').attr({fill:'yellow'});
      $('#tile'+treeID).append(
        $(SVGnode('line'))
        //.attr(endPts(link))  // x1 y1 x2 y3
          .attr(data)
          .attr({
            "class":'branch '+'connection_'+treeID+'_'+link.id
            +' cellBranch_'+link.id.split('_')[0]+' cellBranch_'+link.id.split('_')[1]
            ,
            "stroke-width":10, stroke:'yellow', 
            "marker-end":'url(#marker_arrow)' 
          })
      );
    }     
  }   // update
};


var hiliteTree=(k,__,p)=>{
  p=$('#base2');
  p.empty();
  p.append($(SVGnode('circle')).attr({cx:x(k),cy:y(k),r:5, fill:'orange'}));
  $.map(links,(d)=>{ //find all links that 'carry' a tree
    if(d.cell1 && d.cell1.ports[d.cell1Port] && d.cell1.ports[d.cell1Port].trees[k] &&
       d.cell2 && d.cell2.ports[d.cell2Port] && d.cell2.ports[d.cell2Port].trees[k]   ){
      p.append(
        $(SVGnode('line')).attr(endPts(d)).attr({"stroke-width":4}).attr({stroke:'orange'})
      );
    }
  });
};
var hiliteTree=(k,__,p)=>{  // called by showTrees(0)
  p=$('#tile'+k);
//  p.empty();
//  p.append($(SVGnode('circle')).attr({ 'class':'c_'+k, cx:x(k),cy:y(k),r:5, fill:'orange'}));
  $.map(links,(d)=>{ //find all links that 'carry' a tree
    if(d.cell1 && d.cell1.ports[d.cell1Port] && d.cell1.ports[d.cell1Port].trees[k] &&
       d.cell2 && d.cell2.ports[d.cell2Port] && d.cell2.ports[d.cell2Port].trees[k]   ){
      p.append(
        $(SVGnode('line')).attr(endPts(d)).attr({ "class":'branchline',"stroke-width":4, stroke:'yellow'})
      );
    }
  });
};
// ========================================================= TESTING
var cellsWithTree=(i,__,arr=[])=>{ 
  $.map(cells,(d,k)=>{ if(d.trees[i]){ arr.push(d.id); } });
  return arr;
};
// $.map(cells,(d)=> console.log(d.id,cellsWithTree(d.id)))

var numberOfCellsInEachTree=()=> 
  $.map(cells,
    (tree,k,__,cnt=0)=>{ $.map(cells,(cell)=> cnt+=cell.trees[tree.id] ? 1 : 0 ); return cnt; }
  )
;

// numberOfCellsInEachTree().reduce(function(acc, val) { return acc + val; }, 0);


// ========================================================= CONSOLE/CONTROL
//var base1,base2,svg;  // kludge
var report= (target)=> $(target).data('cell').id+' '+$(target).data('cell').state ;  // zzzzz
report = (target)=> console.log(target)
report = (target)=>{ $('#panel').html($(target).attr('class')); 'see panel' }

var showTrees =(dt)=> $.map(cells,(d,k)=> setTimeout(()=> hiliteTree(k),k*dt) );
var treeCounts=()=> $.map(cells,(d,k)=> console.log(k,$.map(d.trees,(d,k)=> k).length) );


var renderLinks=(svg)=> $.map(links,(d,k)=> $('#toplayer').append( d.view       ) );

var cnt1=0,cnt2=0,cnt3=0;
var ck=()=> console.log((3*cnt1)/(cnt1+cnt2+cnt3),(3*cnt2)/(cnt1+cnt2+cnt3),(3*cnt3)/(cnt1+cnt2+cnt3));
var ops=[
//(__,d)=>{ cnt1++; d=random(links); return d.state!=d.setState('placed'    ); },
  (__,d=random(links))=>{ cnt1++; return d.state!=d.setState('connected1'); }, // may trigger placed
  (__,d=random(links))=>{ cnt1++; return d.state!=d.setState('connected2'); }, // may trigger placed
  (__,d=random(cells))=>{ cnt2++; return d.state!=d.setState('placed'    ); },
  (__,d=random(cells))=>{ cnt3++; return d.state!=d.setState('on'        ); }  // may trigger 'on' of links
];

var DT=2000;
DT=300;
var paused =false;
var pause  =()=>{ paused=true;  };
var resume =()=>{ paused=false; };

var attempt=(__,dt)=> paused ?  50 : (random(ops)() ?  DT : 0) ;  // I could inline w/ next line
var more=()=> setTimeout(more,attempt()); 


// BEHAVIOR
var fool;
var behavior=()=>{
  var div=(s)=>{ return '<DIV>'+s+'</DIV>'; };
  
  $('#resume' ).css({ opacity:0.5 });
  $('#pause'  ).on('click',(ev)=>{ if(!paused){ pause();  $('#pause' ).css({ opacity:0.5 }); $('#resume').css({ opacity:1.0 }); } });
  $('#resume' ).on('click',(ev)=>{ if( paused){ resume(); $('#resume').css({ opacity:0.5 }); $('#pause' ).css({ opacity:1.0 }); } });
  $('#slower' ).on('click',(ev)=>{ DT=DT/2; });
  $('#faster' ).on('click',(ev)=>{ DT=DT*2; });
  $('#tile'   ).on('click',(ev)=>{ ev.stopPropagation(); tile();        });
  $('#stacked').on('click',(ev)=>{ ev.stopPropagation(); stackedView(); });
  $('#nstacked').on('click',(ev)=>{ ev.stopPropagation(); niceStackView(); });
  $('#topview').on('click',(ev)=>{ ev.stopPropagation(); stdView();     }); 
  $('body'    ).on('click','circle',(ev)=>{ ev.stopPropagation(); 
   ///   $('#info').html(report(ev.target)); 
    console.log(fool=$(ev.target)); // use console to examine foo
  
    // array.toString() keeps the ',' but gets rid of the '[' and ']', nuke the ',' w/ .join('')
    $('#panel').html(div($.map($(ev.target).data('cell').trees,(d)=>div(d.id)).join('')));
  });  

};
// =========================================================
var cells;  // []
var links=[];
var linkHash={};
var discoveredCells=[];  // for when a link turns on
$(document).ready(function(__,svg,base1,base2){ 
  layout();
  cells=$.map(d3.range(nCol*nRow),(d,k)=> Cell(k) );
  $.map(cells,(d,k)=> cellHash[d.row+'_'+d.col]=d );
  Links(cells);
  $.map(cells,(d,k)=> $('#content').append(Tile(k)) ); // layer.svg is $('#tile'+k)
  /*
  for(var i=cells.length-1; i>=0; i+= -1){
    $('#content').append(Tile(i)); // layer.svg is $('#tile'+k
  }
  */
  
  $('#content')
    .append($(DIV)
      .attr({'class':"abs baseTile"})
      .css({ width:wid, height:ht })
      .append(svg=$(SVGnode('svg')).attr({ width:wid, height:ht, xmlns:svgNS })
        .append(topLayer=$(SVGnode('g')).attr({ id:"toplayer" }))
        .append(base1   =$(SVGnode('g')).attr({ id:"base1"    }))
        .append(base2   =$(SVGnode('g')).attr({ id:"base2"    }))
      ) 
     )
   .append($(DIV)
      .attr({'class':"abs"})
      .css({ width:1000, height:ht, position:'relative' }) 
      .append($(DIV)
        .attr({id:'connectionTable',position:"relative"})  // abs items positioned wrt a relative 
      )
  );
  renderCells(topLayer);
  renderLinks(topLayer);
  
  stdView();
  $.map($('.tile'),(d,k)=> $(d).css({'z-index':3000-k}));
  
  var defs = $(svg[0]).append($(SVGnode('defs')));  // used for making markers
  
  more();
  /*
  defs.append($(SVGnode('marker').attr({ 
    id:'marker_arrow',
    markerHeight:1,
    markerWidth:1,
    markerUnits:strokeWidth,
    orient:'auto',
    refX:-5,
    refY:0
    viewBox:'-5 -5 10 10',
    .append($(SVGnode('marker').attr( { d:'M 0,0 m -5,-5  L 5,0  L -5,5  Z', fill:'red' }));
  }));
  */

  behavior();
});



var connectionTable_render=(__,sz)=>{
  sz=Math.floor(parseInt($('#connectionTable').parent().css('height').slice(0,-2))/cells.length);
  $('.foobar').remove();
  $.map(cells,(d,k)=>{
    $('#connectionTable').append($(DIV)
      .attr({'class':'abs foobar'})
      .css({   left:k*sz, top: k*sz, width:sz-1, height:sz-1, background:(d.state=='on') ? 'green':'black' })
    );
    $.map(d.trees,(tree,kk)=> 
      $('#connectionTable').append($(DIV)
        .attr({'class':'abs foobar'})
        .css({ left:k*sz, top:kk*sz, width:sz-1, height:sz-1, background:'orange'                          })
      )
    );
  })
};
setInterval(connectionTable_render,1000);


</script>
<pre>
github  earth.org

jgs: dir  server client

topology assumption for grid
k=1     2
  o-----o
  | \ / |
  |  x  | 
  | / \ |
  o-----o  
  3     4
 
ports

jgs:
     5  1  4
      \ | /
    2 - + - 0
      / | \
     6  3  7 

paul    
     8  1  2
      \ | /
    7 - 0 - 3
      / | \
     6  5  4      


node/web server   // emulation of h/w
         wires up using an agreed topology 
            turns things on
         link failure
         tbd: cell failure
         makes and repairs trees   
         zzzz cell.states: on/off   link.states: on/off
         
client/browser            caches and replays events
         getCells,getLinks,getTrees, 
         cmnds: { make(n,m), killLink(t), subscribe(cell,link,tree), }
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
         
=========================

common
Cell  k
Link  k1,p1,k2,p2
del cell  k 
del link  k1,p1,k2,p2
cell.state
link.state 
tree  k  (root)

hiliteTree


Cell.sgate   *unplaced,placed,on
Link.state   *unplaced connected1 connected2 placed on  // on trigger discover
  
triggerDiscover belongs on server


var showTrees =(dt)=> $.map(cells,(d,k)=> setTimeout(()=> hiliteTree(k),k*dt) );
var treeCounts=()=> $.map(cells,(d,k)=> console.log(k,$.map(d.trees,(d,k)=> k).length) );


var renderLinks=(svg)=> $.map(links,(d,k)=> $('#toplayer').append( d.view       ) );

var ops=[
  (__,d=random(links))=>{ cnt1++; return d.state!=d.setState('connected1'); }, // may trigger placed
  (__,d=random(links))=>{ cnt1++; return d.state!=d.setState('connected2'); }, // may trigger placed
  (__,d=random(cells))=>{ cnt2++; return d.state!=d.setState('placed'    ); },
  (__,d=random(cells))=>{ cnt3++; return d.state!=d.setState('on'        ); }  // may trigger 'on' of links
];

var attempt=(__,dt)=> paused ?  50 : (random(ops)() ?  DT : 0) ;  // I could inline w/ next line
var more=()=> setTimeout(more,attempt()); 

tbd:
 timeline and spaceout
</pre>
